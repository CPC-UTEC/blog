<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Class 08: Complete Search V</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<!--Let browser know website is optimized for mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<!-- Gallery library -->
<link rel="stylesheet" type="text/css" href="lib/lightbox.min.css">

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 54px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h2 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h3 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h4 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h5 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h6 {
  padding-top: 59px;
  margin-top: -59px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">



<div class="wrapper">

<!-- Sidebar Holder -->
<nav id="sidebar">
<div class="sidebar-header">
  <h3 style="text-align: left;">
    <a style="text-decoration: none;"href="./index.html">
      Competitive programming UTEC
    </a>
  </h3>
  <strong>
    <a style="text-decoration: none;"href="./index.html">
    CP-UTEC
    </a>
  </strong>
</div>

<div id="dismiss-left">
  <i class="fa fa-arrow-left"></i>
</div>

<div id="dismiss-right">
  <i class="fa fa-arrow-right"></i>
</div>

<ul class="list-unstyled components">

  <div class="line"></div>
  
  <li id="index-page">
    <a href="./index.html">
      Home
    </a>
  </li>

  <div class="line"></div>

  <li id="schedule-page">
    <a href="./schedule.html">
      Schedule
    </a>
  </li>

  <div class="line"></div>

  <li id="classes-page-expanded">
    <a id="classes" href="#all-classes" data-toggle="collapse"
      aria-expanded="false">
      Classes
    </a>
    <ul class="collapse list-unstyled" id="all-classes">
      <li id="class-01">
        <a href="./class-01.html">1. Introduction</a>
      </li>
      <li id="class-02">
        <a href="./class-02.html">2. Asymptotic Analysis</a>
      </li>
      <li id="class-03">
        <a href="./class-03.html">3. Standard Template Library</a>
      </li>
      <li id="class-04">
        <a href="./class-04.html">4. Complete Search I</a>
      </li>
      <li id="class-05">
        <a href="./class-05.html">5. Complete Search II</a>
      </li>
      <li id="class-06">
        <a href="./class-06.html">6. Complete Search III</a>
      </li>
      <li id="class-07">
        <a href="./class-07.html">7. Complete Search IV</a>
      </li>
      <li id="class-08">
        <a href="./class-08.html">8. Complete Search V</a>
      </li>
      <li id="class-09">
        <a href="./class-09.html">9. Contest I</a>
      </li>
      <li id="class-10">
        <a href="./class-10.html">10. Contest UTEC-UNI-UPC I</a>
      </li>
      <li id="class-11">
        <a href="./class-11.html">11. Divide and Conquer I</a>
      </li>
      <li id="class-12">
        <a href="./class-12.html">12. Divide and Conquer II</a>
      </li>
      <li id="class-13">
        <a href="./class-13.html">13. Game Theory I</a>
      </li>
      <li id="class-14">
        <a href="./class-14.html">14. Game Theory II</a>
      </li>
      <li id="class-15">
        <a href="./class-15.html">15. Contest II</a>
      </li>
      <li id="class-16">
        <a href="./class-15.html">16. Contest UTEC-UNI-UPC II</a>
      </li>
    </ul>
  </li>

  <div class="line"></div>

  <li id="classes-page-not-expanded">
    <a href="./classes.html">
      Classes
    </a>
  </li>

  <div class="line"></div>

  <li id="daily-problem-page">
    <a href="./daily-problem.html">
      Daily problem
    </a>
  </li>

  <div class="line"></div>

  <li id="gallery-page">
    <a href="./gallery.html">
      Gallery
    </a>
  </li>

  <div class="line"></div>

</ul>


<!--
<ul class="list-unstyled">
  <li>
    <a href="https://www.utec.edu.pe/" target="_blank" class="logo">
      <img src="images/page/utec-logo.png" alt="UTEC logo">
    </a>
  </li>
</ul>
-->
</nav>

<div id="expand-icon-right">
  <i class="fa fa-angle-right"></i>
</div>

<div id="expand-icon-left">
  <i class="fa fa-angle-left"></i>
</div>

<!-- Page Content Holder -->
<div id="content">
<script>
$(".main-container")
  .removeClass("main-container")
  .removeClass("container-fluid")
</script>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Class 08: Complete Search V</h1>
<h4 class="date">01-29-2020</h4>

</div>


<blockquote>
<p>“Like the God of go”</p>
</blockquote>
<div class="topic">
Power set
</div>
<p>The power set of a set is the set of all its subsets. For example:</p>
<p><span class="math display">\[A = \{1, 2, 3\}\]</span> <span class="math display">\[P(A) = \{\emptyset, \{1\},  \{2\},  \{3\},  \{1, 2\},  \{2, 3\},  \{1, 3\}, \{1, 2, 3\} \}\]</span></p>
<p>Here <span class="math inline">\(P(A)\)</span> represents the power set of the set <span class="math inline">\(A\)</span>. Moreover, we have that <span class="math inline">\(|P(A)| = 2^{|A|}\)</span>.</p>
<p><strong>Extra:</strong> In some books, <span class="math inline">\(P(A)\)</span> is written as <span class="math inline">\(2^{A}\)</span> (e.g <a href="https://www.amazon.com/-/es/Jiri-Matousek/dp/0198570422">Motousek - Invitation to Discrete Mathematics</a>).</p>
<p>We already know how to generate the power set of <span class="math inline">\(A = \{1, 2, 3, \dots, n\}\)</span> using bitmasks.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembitmask" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembitmask" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

int main () {
  int n = 3;
  for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
    vector &lt;int&gt; subset;
    for (int bit = 0; bit &lt; n; bit++) {
      if ((mask &gt;&gt; bit) &amp; 1) {
        subset.push_back(bit + 1);
      }
    }
    print(subset);
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>But, we can also generate it using recursion, but before that, let’s review about passing arguments to a function in C++.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
using namespace std;
     
// Here is passed a reference to &#39;arr&#39; in O(1)
// You CAN read from &#39;arr&#39;, but you CAN NOT modify it
void f1 (const vector &lt;int&gt;&amp; arr) {

}
     
// Here is passed a reference to &#39;arr&#39; in O(1)
// You CAN read from &#39;arr&#39; and you CAN modify it
void f2 (vector &lt;int&gt;&amp; arr) {
}
     
// Here is passed a copy of &#39;arr&#39; in O(n)
// You CAN read from &#39;arr&#39; and you CAN modify it
// BUT, you are modifying a copy of &#39;arr&#39;, not the &#39;arr&#39; of &#39;main&#39;
void f3 (vector &lt;int&gt; arr) {
     
}
     
int main () {
  int n = 10000;
  vector &lt;int&gt; arr(n);
  for (int i = 0; i &lt; n; i++) {
    arr[i] = i;
  }
  f1(arr);
  f2(arr);
  f3(arr);
  return (0);
}</code></pre>
<p>If we want to generate the power set of <span class="math inline">\(A = \{1, 2, 3\}\)</span>, we can make a function that follows these states:</p>
<div class="row text-center">
<p><img src="images/class-08/power-set.png" /></p>
</div>
<p>That is, if we are in the state <span class="math inline">\((a_1, a_2, \dots a_x) \mid a_1 &lt; a_2 &lt; \dots &lt; a_x\)</span>, then we can go to <span class="math inline">\((a_1, a_2, \dots, a_x, a_y) \mid a_x &lt; a_y \leq n\)</span>.</p>
<p>And we can implement it using recursion.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

void backtrack (vector &lt;int&gt;&amp; arr, const int n) {
  print(arr);
  int ax = 0;
  if (!arr.empty()) {
    ax = arr.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // add ay
    arr.push_back(ay);
    backtrack(arr, n);
    // delete ay
    arr.pop_back();
  }
}

int main () {
  int n = 3;
  vector &lt;int&gt; subset;
  backtrack(subset, n);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>But, in competitive programming, we usually try to have as few parameters in our functions as possible. Then, we realize that we can implement it in this way (<strong>why?</strong>).</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set-global" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set-global" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

// global variables
vector &lt;int&gt; subset;
int n;

void backtrack () {
  print(subset);
  int ax = 0;
  if (!subset.empty()) {
    ax = subset.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // add ay
    subset.push_back(ay);
    backtrack();
    // delete ay
    subset.pop_back();
  }
}

int main () {
  n = 3;
  backtrack();
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Here we have implemented a program to find the power set of <span class="math inline">\(\{1, 2, 3, \dots, n\}\)</span> in <span class="math inline">\(O(n 2 ^ n)\)</span>. This is a solution using what is known as <code>backtracking</code>. In general, a backtracking solution has this form:</p>
<pre class="bw"><code>let state be a global variable

T backtrack (some parameters):
  if (state is a terminal state):
    Do something with &#39;state&#39; and return something
  
  for (state&#39; reachable from state):
    # do something
    previous = state
    state = state&#39;
    backtrack(some parameters&#39;)
    # reverse changes
    state = previous</code></pre>
<p>A terminal state is a state in which we can not go to other states (or it is not convenient to follow searching).</p>
<div class="topic">
0-1 Knapsack problem
</div>
<p><strong>Problem:</strong> You have a knapsack of capacity <span class="math inline">\(W\)</span> (i.e you can put at most <span class="math inline">\(W\)</span> kg in this knapsack). Moreover, you have <span class="math inline">\(n\)</span> items. Each item is describe as a pair <span class="math inline">\((val_i, w_i)\)</span>, where <span class="math inline">\(val_i\)</span> is the cost of the item and <span class="math inline">\(w_i\)</span> the weight of it. Find the maximum value you can store in this knapsack using the least possible weight.</p>
<p><span class="math display">\[1 \leq n \leq 16\]</span></p>
<p><strong>Solution:</strong></p>
<p>Each item can be taken or not, then we can search over all the possibilites (power set) using bitmasks or backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblem0-1-knapsack" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblem0-1-knapsack" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int W;
vector &lt;int&gt; val;
vector &lt;int&gt; w;
vector &lt;int&gt; take;
int max_sum_val = 0;
int min_sum_w = 0;
vector &lt;int&gt; ans_items_taken;

void backtrack (int last_taken, int sum_val, int sum_w) {
  if (sum_w &lt;= W and (sum_val &gt; max_sum_val or
      (sum_val == max_sum_val and sum_w &lt; min_sum_w))) {
    max_sum_val = sum_val;
    min_sum_w = sum_w;
    ans_items_taken = take;
  }
  for (int i = last_taken + 1; i &lt; n; i++) {
    take.push_back(i);
    backtrack(i, sum_val + val[i], sum_w + w[i]);
    take.pop_back();
  }
}

int main () {
  n = 3;
  W = 10;
  // item 1
  val.push_back(10);
  w.push_back(10);
  // item 2
  val.push_back(1);
  w.push_back(8);
  // item 3
  val.push_back(13);
  w.push_back(2);
  backtrack(-1, 0, 0);

  cout &lt;&lt; &quot;Take items&quot;;
  for (int item: ans_items_taken) {
    cout &lt;&lt; &#39; &#39; &lt;&lt; item + 1;
  }
  cout &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<div class="topic">
Permutations
</div>
<p>The problem of generating all the permutations can also be easily computed using backtracking in <span class="math inline">\(O(n n!)\)</span></p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblempermutation" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblempermutation" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;bool&gt; used;
vector &lt;int&gt; permutation;

void print (const vector &lt;int&gt;&amp; p) {
  for (int elem: p) {
    cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
  }
  cout &lt;&lt; &#39;\n&#39;;
}

void backtrack () {
  if (permutation.size() == n) {
    print(permutation);
    return;
  }
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used[p_i] = false;
      permutation.pop_back();
    }
  }
}

int main () {
  n = 3;
  used.resize(n + 1, false);
  backtrack();
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Here we are following these states:</p>
<div class="row text-center">
<p><img src="images/class-08/permutation.png" /></p>
</div>
<p>This image represents what is called the <strong>recursion tree</strong>. It show us how the function do the transitions.</p>
<p>Moreover, notice that we do not need to do something like this:</p>
<pre class="cpp"><code>.
.
.
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      vector &lt;bool&gt; used_previous = used;
      vector &lt;int&gt; permutation_previous = permutation;
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used = used_previous;
      permutation = permutation_previous;
    }
  }
.
.
.</code></pre>
<p>Because it will be heavier that the first solution and we know that:</p>
<ul>
<li>If previous of calling the recursion we ADD an element TO THE END of the vector, then after the recursion we must DELETE THE LAST element of the vector.</li>
<li>If previous of calling the recursion we SET TO TRUE an element, then after the recursion we must SET TO FALSE that element.</li>
<li>If previous of calling the recursion we ADD something, then after the recursion we must SUBTRACT something.</li>
<li>Following this logic, If previous of calling the recursion we DO ONE OPERATION, then after the recursion we must REVERSE that operation. If the operation is complicated we can just save a copy of the previous state, else we can try to reverse the operations.</li>
</ul>
<p>From all this one notice that if you are in your recursion in some <code>state</code> and you go to <code>state'</code>, then after returning of traversing the recursion tree of <code>state'</code> you expect to have some variables in the condition they were before traversing the recursion tree of <code>state'</code>. Understanding this idea is the key to implement backtracking solutions.</p>
<div class="topic">
Sudoku
</div>
<p>With backtracking it is easy to generate all possible movements in a game and choose the best movement.</p>
<p><strong>Problem:</strong></p>
<div class="row text-center">
<p><img src="images/class-08/sudoku1.png" /></p>
</div>
<p>Complete the above sudoku such that each number from 1 to 9 is found just once in each row, column and quadrant.</p>
<p><strong>Solution:</strong> We can just search all possible solutions using bactracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemsudoku" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemsudoku" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector &lt;vector &lt;int&gt;&gt; sudoku;
vector &lt;vector &lt;int&gt;&gt; sudoku_solved;
vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; quadrant;
int n;
int N;
bool found;

bool validInRow (int r, int d) {
  for (int c = 0; c &lt; N; c++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInCol (int c, int d) {
  for (int r = 0; r &lt; N; r++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInQuadrant (int q, int d) {
  for (pair &lt;int, int&gt; pos: quadrant[q]) {
    int r = pos.first;
    int c = pos.second;
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

// run this function for every 0 &lt;= r &lt; N and 0 &lt;= c &lt; N and you will get
// what this function does
int getQuadrant (int r, int c) {
  return (r / n) * n + (c / n);
}

void backtrack (int r, int c) {
  if (r == N) {
    found = true;
    sudoku_solved = sudoku;
    return;
  }
  if (found) {
    return;
  }
  int nc = (c + 1 == N) ? 0 : c + 1; // new column
  int nr = (c + 1 == N) ? r + 1 : r; // new row
  if (sudoku[r][c] != 0) {
    backtrack(nr, nc);
    return;
  } 
  for (int d = 1; d &lt;= 9; d++) {
    int quadrant = getQuadrant(r, c);
    if (validInRow(r, d) and
        validInCol(c, d) and
        validInQuadrant(getQuadrant(r, c), d)) {
      sudoku[r][c] = d;
      backtrack(nr, nc);
      sudoku[r][c] = 0;
    }
  }
}

void precomputation () {
  found = false;
  N = sudoku.size();
  n = 1;
  while ((n + 1) * (n + 1) &lt;= N) n++;
  // n = sqrt(N)
  quadrant.resize(N);
  for (int r = 0; r &lt; N; r++) {
    for (int c = 0; c &lt; N; c++) {
      quadrant[getQuadrant(r, c)].push_back({r, c});
    }
  }
}

void print (const vector &lt;vector &lt;int&gt;&gt;&amp; sudoku) {
  for (auto row: sudoku) {
    for (int elem: row) {
      cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; &#39;\n&#39;;
  }
}

int main () {
  sudoku = {
            {3, 0, 6, 5, 0, 8, 4, 0, 0},  
            {5, 2, 0, 0, 0, 0, 0, 0, 0},  
            {0, 8, 7, 0, 0, 0, 0, 3, 1},  
            {0, 0, 3, 0, 1, 0, 0, 8, 0},  
            {9, 0, 0, 8, 6, 3, 0, 0, 5},  
            {0, 5, 0, 0, 9, 0, 6, 0, 0},  
            {1, 3, 0, 0, 0, 0, 2, 5, 0},  
            {0, 0, 0, 0, 0, 0, 0, 7, 4},  
            {0, 0, 5, 2, 0, 6, 3, 0, 0}
           };
  precomputation();
  backtrack(0, 0);
  print(sudoku_solved);
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>With this code we get this solution:</p>
<div class="row text-center">
<p><img src="images/class-08/sudoku2.png" /></p>
</div>
<div class="topic">
N-queen problem
</div>
<p><strong><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">Problem:</a></strong> Given a chess board having <span class="math inline">\(N \times N\)</span> cells, you need to place <span class="math inline">\(N\)</span> queens on the board in such a way that no queen attacks any other queen.</p>
<p><span class="math display">\[1 \leq N \leq 10\]</span></p>
<p><strong>Remember:</strong> A queen can attack in a complete row, column or diagonal.</p>
<p><strong>Solution:</strong> We could try to place N queen in the <span class="math inline">\(N \times N\)</span> cells. In this way we may get <span class="math inline">\(\binom{N \times N}{N}\)</span> states to check. But for <span class="math inline">\(N = 8\)</span> we have that <span class="math inline">\(\binom{N \times N}{N} \approx 8B\)</span>, so we need a better approach.</p>
<p>We know that each queen should be in different columns (else they will be attacking each other). So we can generate these <span class="math inline">\(N^N\)</span> possible configurations and check if the conditions holds, but this solution may not be enough.</p>
<p>We know that each queen should be in different rows and columns. Then, the rows of the queens of a valid configuration are a permutation. The same holds for the columns. Thereby, we have <span class="math inline">\(N!\)</span> possible configurations to check. We can implement this idea using backtracking in this way:</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemn-queen" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemn-queen" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;pair &lt;int, int&gt;&gt; queen;
vector &lt;pair &lt;int, int&gt;&gt; solution;

bool valid (int r, int c) {
  for (auto pp: queen) {
    // if same row or same column or same diagonal
    if ((pp.first == r) or
        (pp.second == c) or
        (abs(r - pp.first) == abs(c - pp.second))) {
      return false;
    }
  }
  return true;
}

void backtrack (int r) {
  if (r == n) {
    solution = queen;
    return;
  }
  if (!solution.empty()) {
    return;
  }
  for (int c = 0; c &lt; n; c++) {
    if (valid(r, c)) {
      queen.push_back({r, c});
      backtrack(r + 1);
      queen.pop_back();
    }
  }
}

int main () {
  cin &gt;&gt; n;
  backtrack(0);
  if (solution.empty()) {
    cout &lt;&lt; &quot;NO\n&quot;;
    return (0);
  }
  vector &lt;vector &lt;int&gt;&gt; board(n, vector &lt;int&gt; (n, 0));
  for (auto pp: solution) {
    board[pp.first][pp.second] = 1;
  }
  cout &lt;&lt; &quot;YES\n&quot;;
  for (int r = 0; r &lt; n; r++) {
    for (int c = 0; c &lt; n; c++) {
      cout &lt;&lt; board[r][c] &lt;&lt; &quot; \n&quot;[c == n - 1];
    }
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>For <span class="math inline">\(N = 4\)</span> the recursion tree of our solution is like this:</p>
<div class="row text-center img-border">
<p><img src="images/class-08/n-queen.png" /></p>
<p>Image taken from <a href="http://jeffe.cs.illinois.edu/teaching/algorithms/">Jeff Erickson - Algorithms - Chapter 2: Backtracking</a>.</p>
</div>
<p>The complexity of the above solution comes from the equation:</p>
<p><span class="math display">\[T_n = n \cdot T_{n - 1} + O(n)\]</span> <span class="math display">\[\to T_n = O(n!)\]</span></p>
<p>Then, our solution has complexity <span class="math inline">\(O(n!)\)</span>.</p>
<p>Recommended readings:</p>
<ul>
<li><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">HackerEarth - Recursion and Backtracking</a></li>
<li>Competitive Programming 3, section 3.2.2, 8.2.1 and 8.2.2.</li>
<li><a href="https://www.geeksforgeeks.org/backtracking-algorithms/">GeekForGeeks - Backtracking Algorithms</a></li>
</ul>
<div id="contest" class="topic">
Contest
</div>
<p>You can find the contest <a href="https://vjudge.net/contest/354334">here</a>.</p>
<!-- Begins problem A -->
<div id="A" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
A: CD
</p>
</div>
<!-- begin body -->
<div id="collapseProblemA" class="collapse">
<div class="card-body solution-body">
<h3 id="cd"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=565" target="_blank">CD</a></h3>
<p>Each element can be taken or not, then a backtracking solution will give us the answer and keet the initial order of the items.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemA" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
using namespace std;
 
int main () {
  int n;
  while (cin &gt;&gt; n) {
    int m;
    cin &gt;&gt; m;
    vector &lt;int&gt; arr(m);
    for (int&amp; elem: arr) cin &gt;&gt; elem;
    vector &lt;int&gt; take;
    vector &lt;int&gt; ans;
    int sum = 0;
    int best_sum = 0;

    function &lt;void(int)&gt; backtrack = [&amp;] (int pos) -&gt; void {
      if (sum &gt; best_sum or (sum == best_sum and ans.size() &lt; take.size())) {
        best_sum = sum;
        ans = take;
      }
      if (pos == m) return;
      // do not take it
      backtrack(pos + 1);
      if (sum + arr[pos] &gt; n) return;
      // take it
      take.push_back(arr[pos]);
      sum += arr[pos];
      backtrack(pos + 1);
      take.pop_back();
      sum -= arr[pos];
    };

    backtrack(0);
    for (int elem: ans) cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
    cout &lt;&lt; &quot;sum:&quot; &lt;&lt; best_sum &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem A -->
<!-- Begins problem B -->
<div id="B" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
B: Hanoi Tower Troubles Again!
</p>
</div>
<!-- begin body -->
<div id="collapseProblemB" class="collapse">
<div class="card-body solution-body">
<h3 id="hanoi-tower-troubles-again"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1217" target="_blank">Hanoi Tower Troubles Again!</a></h3>
<p>There is a greedy approach, you can put a ball in the first pile where you can do it.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemB" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  const int N = 1e5;
  vector &lt;bool&gt; is_sq(N, false);
  for (int i = 0; i * i &lt; N; i++) is_sq[i * i] = true;
  int tc;
  cin &gt;&gt; tc;
  while (tc--) {
    int n;
    cin &gt;&gt; n;
    vector &lt;vector &lt;int&gt;&gt; pile(n);
    int ans = 0;
    int cur = 0;

    function &lt;void(int)&gt; rec = [&amp;] (int num) -&gt; void {
      ans = max(ans, cur);
      for (int i = 0; i &lt; n; i++) {
        if (pile[i].empty() or is_sq[pile[i].back() + num]) {
          cur += 1;
          pile[i].push_back(num);
          rec(num + 1);
          break;
        }
      }
    };

    rec(1);
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem B -->
<!-- Begins problem C -->
<div id="C" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
C: Marcus
</p>
</div>
<!-- begin body -->
<div id="collapseProblemC" class="collapse">
<div class="card-body solution-body">
<h3 id="marcus"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1393" target="_blank">Marcus</a></h3>
<p>Identify the initial point and then search on the grid using backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemC" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  const vector &lt;int&gt; dr = {-1, 0, 0};
  const vector &lt;int&gt; dc = {0, -1, 1};
  const vector &lt;string&gt; option = {&quot;forth&quot;, &quot;left&quot;, &quot;right&quot;};
  const string word = &quot;IEHOVA#&quot;;
  int tc;
  cin &gt;&gt; tc;
  while (tc--) {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector &lt;string&gt; ans;
    vector &lt;string&gt; take;
    vector &lt;string&gt; grid(n);
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];

    function &lt;void(int,int)&gt; backtrack = [&amp;] (int r, int c) -&gt; void {
      if (take.size() == 7) {
        ans = take;
        return;
      }
      for (int d = 0; d &lt; 3; d++) {
        if (!ans.empty()) return;
        int nr = r + dr[d];
        int nc = c + dc[d];
        if (not (0 &lt;= min(nr, nc) and nr &lt; n and nc &lt; m)) continue;
        if (grid[nr][nc] != word[take.size()]) continue;
        take.push_back(option[d]);
        backtrack(nr, nc);
        take.pop_back();
      }
    };

    for (int r = 0; r &lt; n; r++) {
      for (int c = 0; c &lt; m; c++) {
        if (grid[r][c] == &#39;@&#39;) {
          backtrack(r, c);
        }
      }
    }
    for (int i = 0; i &lt; 7; i++) {
      cout &lt;&lt; ans[i] &lt;&lt; &quot; \n&quot;[i == 6];
    }
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem C -->
<!-- Begins problem D -->
<div id="D" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
D: Back to the 8-Queens
</p>
</div>
<!-- begin body -->
<div id="collapseProblemD" class="collapse">
<div class="card-body solution-body">
<h3 id="back-to-the-8-queens"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2026" target="_blank">Back to the 8-Queens</a></h3>
<p>There are just 92 valid configurations, we can generate all of them using backtracking and do a simple linear search to get the answer for each query.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemD" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 8;
vector &lt;pair &lt;int, int&gt;&gt; queen;
vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; solution;

bool valid (int r, int c) {
  for (auto pp: queen) {
    // if same row or same column or same diagonal
    if ((pp.first == r) or
        (pp.second == c) or
        (abs(r - pp.first) == abs(c - pp.second))) {
      return false;
    }
  }
  return true;
}

void backtrack (int c) {
  if (c == N + 1) {
    solution.push_back(queen);
    return;
  }
  for (int r = 1; r &lt;= N; r++) {
    if (valid(r, c)) {
      queen.push_back({r, c});
      backtrack(c + 1);
      queen.pop_back();
    }
  }
}

int main () {
  backtrack(1);
  vector &lt;int&gt; row(N);
  int tc = 0;
  while (cin &gt;&gt; row[0]) {
    for (int i = 1; i &lt; N; i++) cin &gt;&gt; row[i];
    int ans = INT_MAX;
    for (auto sol: solution) {
      int need = 0;
      for (int i = 0; i &lt; N; i++) {
        need += (row[i] != sol[i].first);
      }
      ans = min(ans, need);
    }
    cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++tc &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem D -->
<!-- Begins problem E -->
<div id="E" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
E: Boggle Blitz
</p>
</div>
<!-- begin body -->
<div id="collapseProblemE" class="collapse">
<div class="card-body solution-body">
<h3 id="boggle-blitz"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=428" target="_blank">Boggle Blitz</a></h3>
<p>Just use backtracking to do a complete search.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemE" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main () {
  int tc;
  cin &gt;&gt; tc;
  for (int t = 0; t &lt; tc; t++) {
    if (t) cout &lt;&lt; &#39;\n&#39;;
    int n;
    cin &gt;&gt; n;
    vector &lt;string&gt; grid(n);
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; grid[i];
    vector &lt;string&gt; ans;
    string word = &quot;&quot;;

    function &lt;void(int,int,char)&gt; backtrack = [&amp;] (int r, int c, char last) -&gt; void {
      if (3 &lt;= word.size()) {
        ans.push_back(word);
      }
      for (int dr = -1; dr &lt;= 1; dr++) {
        for (int dc = -1; dc &lt;= 1; dc++) {
          if (dr == 0 and dc == 0) continue;
          int nr = r + dr;
          int nc = c + dc;
          if (not (0 &lt;= min(nr, nc) and max(nr, nc) &lt; n)) continue;
          if (grid[nr][nc] &lt;= last) continue;
          word += grid[nr][nc];
          backtrack(nr, nc, grid[nr][nc]);
          word.pop_back();
        }
      }
    };

    for (int r = 0; r &lt; n; r++) {
      for (int c = 0; c &lt; n; c++) {
        word += grid[r][c];
        backtrack(r, c, grid[r][c]);
        word.pop_back();
      }
    }
    sort(begin(ans), end(ans), [&amp;] (const string&amp; x, const string&amp; y) {
      if (x.size() != y.size()) return x.size() &lt; y.size();
      return x &lt; y;  
    });
    // delete duplicates
    ans.erase(unique(begin(ans), end(ans)), end(ans));
    for (auto&amp; word: ans) cout &lt;&lt; word &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem E -->
<p style="float: none; clear: both;">
</p>
<div class="pt-3" style="float: right;">
<p><a class="continue-link" href="./class-09.html" 
     data-toggle="tooltip" title="Contest I"> Next </a></p>
</div>
<div class="pt-3">
<p><a class="continue-link" href="./class-07.html"
     data-toggle="tooltip" title="Complete Search IV"> Previous </a></p>
</div>
<script>
  $('#all-classes').collapse('show');
  $('#class-08').addClass('active');
  const cur_class = document.getElementById('class-08');
  cur_class.scrollIntoView({
    behavior: 'smooth',
    block: 'center'
  });
</script>

</div> <!-- ends wrapper -->
</div> <!-- ends content -->


<script type="text/javascript">

$(document).ready(function () {
  $('#dismiss-left').on('click', function () {
    $('#sidebar, #content').addClass('active');
  });

  $('#dismiss-right').on('click', function () {
    $('#sidebar, #content').removeClass('active');
  });

  $('#expand-icon-right').on('click', function () {
    document.getElementById('sidebar').style.width = "90px";
    document.getElementById('expand-icon-right').style.display = "none";
    document.getElementById('expand-icon-left').style.display = "block";
    $('#expand-icon-left').addClass('moved');
    $('#expand-icon-right').addClass('moved');
  });

  $('#expand-icon-left').on('click', function () {
    document.getElementById('sidebar').style.width = "0px";
    document.getElementById('expand-icon-right').style.display = "block";
    document.getElementById('expand-icon-left').style.display = "none";
    $('#expand-icon-left').removeClass('moved');
    $('#expand-icon-right').removeClass('moved');
  });

});

</script>

<script type="text/javascript" src="lib/lightbox-plus-jquery.min.js"></script>

<!--
<footer>
  <p>Copyright &copy; 2020. Competitive Programming UTEC</p>
</footer>
-->



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
