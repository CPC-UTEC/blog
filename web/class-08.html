<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Clase 08: Complete Search IV</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<script src="site_libs/elevate-section-attrs-2.0/elevate-section-attrs.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 45px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h2 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h3 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h4 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h5 {
  padding-top: 50px;
  margin-top: -50px;
}
.section h6 {
  padding-top: 50px;
  margin-top: -50px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CP UTEC</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="schedule.html">Schedule</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Lessons
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 1</li>
    <li>
      <a href="class-01.html">The Art of Thinking</a>
    </li>
    <li>
      <a href="class-02.html">Think Big</a>
    </li>
    <li class="dropdown-header">Week 2</li>
    <li>
      <a href="class-03.html">Don't reinvent the wheel!</a>
    </li>
    <li>
      <a href="class-04.html">Try every possibility</a>
    </li>
    <li class="dropdown-header">Week 3</li>
    <li>
      <a href="class-05.html">Keep it simple and straightforward</a>
    </li>
    <li>
      <a href="class-06.html">Think twice, code once</a>
    </li>
    <li class="dropdown-header">Week 4</li>
    <li>
      <a href="class-07.html">Turning out the mask</a>
    </li>
    <li>
      <a href="class-08.html">Like the God of Go</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="daily-problem.html">Daily Problem</a>
</li>
<li>
  <a href="gallery.html">Gallery</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Clase 08: Complete Search IV</h1>
<h4 class="date">29-01-2020</h4>

</div>


<blockquote>
<p>“Like the God of Go”</p>
</blockquote>
<div class="topic">
Power set
</div>
<p>The power set of a set is the set of all its subsets. For example:</p>
<p><span class="math display">\[A = \{1, 2, 3\}\]</span> <span class="math display">\[P(A) = \{\emptyset, \{1\},  \{2\},  \{3\},  \{1, 2\},  \{2, 3\},  \{1, 3\}, \{1, 2, 3\} \}\]</span></p>
<p>Here <span class="math inline">\(P(A)\)</span> represents the power set of the set <span class="math inline">\(A\)</span>. Moreover, we have that <span class="math inline">\(|P(A)| = 2^{|A|}\)</span>.</p>
<p><strong>Extra:</strong> In some books, <span class="math inline">\(P(A)\)</span> is written as <span class="math inline">\(2^{A}\)</span> (e.g <a href="https://www.amazon.com/-/es/Jiri-Matousek/dp/0198570422">Motousek - Invitation to Discrete Mathematics</a>).</p>
<p>We already know how to generate the power set of <span class="math inline">\(A = \{1, 2, 3, \dots, n\}\)</span> using bitmasks.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembitmask" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembitmask" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

int main () {
  int n = 3;
  for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
    vector &lt;int&gt; subset;
    for (int bit = 0; bit &lt; n; bit++) {
      if ((mask &gt;&gt; bit) &amp; 1) {
        subset.push_back(bit + 1);
      }
    }
    print(subset);
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>But, we can also generate it using recursion, but before that, let’s review about passing arguments to a function in C++.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
using namespace std;
     
// Here is passed a reference to &#39;arr&#39; in O(1)
// You CAN read from &#39;arr&#39;, but you CAN NOT modify it
void f1 (const vector &lt;int&gt;&amp; arr) {

}
     
// Here is passed a reference to &#39;arr&#39; in O(1)
// You CAN read from &#39;arr&#39; and you CAN modify it
void f2 (vector &lt;int&gt;&amp; arr) {
}
     
// Here is passed a copy of &#39;arr&#39; in O(n)
// You CAN read from &#39;arr&#39; and you CAN modify it
// BUT, you are modifying a copy of &#39;arr&#39;, not the &#39;arr&#39; of &#39;main&#39;
void f3 (vector &lt;int&gt; arr) {
     
}
     
int main () {
  int n = 10000;
  vector &lt;int&gt; arr(n);
  for (int i = 0; i &lt; n; i++) {
    arr[i] = i;
  }
  f1(arr);
  f2(arr);
  f3(arr);
  return (0);
}</code></pre>
<p>If we want to generate the power set of <span class="math inline">\(A = \{1, 2, 3\}\)</span>, we can make a function that follows these states:</p>
<div class="row text-center">
<p><img src="images/class-08/power-set.png" /></p>
</div>
<p>That is, if we are in the state <span class="math inline">\((a_1, a_2, \dots a_x) \mid a_1 &lt; a_2 &lt; \dots &lt; a_x\)</span>, then we can go to <span class="math inline">\((a_1, a_2, \dots, a_x, a_y) \mid a_x &lt; a_y \leq n\)</span>.</p>
<p>And we can implement it using recursion.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

void backtrack (vector &lt;int&gt;&amp; arr, const int n) {
  print(arr);
  int ax = 0;
  if (!arr.empty()) {
    ax = arr.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // add ay
    arr.push_back(ay);
    backtrack(arr, n);
    // delete ay
    arr.pop_back();
  }
}

int main () {
  int n = 3;
  vector &lt;int&gt; subset;
  backtrack(subset, n);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>But, in competitive programming, we usually try to have as few parameters in our functions as possible. Then, we realize that we can implement it in this way (<strong>why?</strong>).</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblembacktrack-power-set-global" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblembacktrack-power-set-global" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void print (const vector &lt;int&gt;&amp; arr) {
  cout &lt;&lt; &quot;{&quot;;
  bool first = true;
  for (int elem: arr) {
    if (!first) {
      cout &lt;&lt; &quot;, &quot;;
    }
    cout &lt;&lt; elem;
    first = false;
  }
  cout &lt;&lt; &quot;}\n&quot;;
}

// global variables
vector &lt;int&gt; subset;
int n;

void backtrack () {
  print(subset);
  int ax = 0;
  if (!subset.empty()) {
    ax = subset.back();
  }
  for (int ay = ax + 1; ay &lt;= n; ay++) {
    // add ay
    subset.push_back(ay);
    backtrack();
    // delete ay
    subset.pop_back();
  }
}

int main () {
  n = 3;
  backtrack();
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Here we have implemented a program to find the power set of <span class="math inline">\(\{1, 2, 3, \dots, n\}\)</span> in <span class="math inline">\(O(n 2 ^ n)\)</span>. This is a solution using what is known as <code>backtrackin</code>. In general, a backtracking solution has this form:</p>
<pre class="bw"><code>let state be a global variable

T backtrack (some parameters):
  if (state is a terminal state):
    Do something with &#39;state&#39; and return something
  
  for (state&#39; reachable from state):
    # do something
    previous = state
    state = state&#39;
    backtrack(some parameters&#39;)
    # reverse changes
    state = previous</code></pre>
<p>A terminal state is a state in which we can not go to other states (or it is not convenient to follow searching).</p>
<div class="topic">
0-1 Knapsack problem
</div>
<p><strong>Problem:</strong> You have a knapsack of capacity <span class="math inline">\(W\)</span> (i.e you can put at most <span class="math inline">\(W\)</span> kg in this knapsack). Moreover, you have <span class="math inline">\(n\)</span> items. Each item is describe as a pair <span class="math inline">\((val_i, w_i)\)</span>, where <span class="math inline">\(val_i\)</span> is the cost of the item and <span class="math inline">\(w_i\)</span> the weight of it. Find the maximum value you can store in this knapsack using the least possible weight.</p>
<p><span class="math display">\[1 \leq n \leq 16\]</span></p>
<p><strong>Solution:</strong></p>
<p>Each item can be taken or not, then we can search over all the possibilites (power set) using bitmasks or backtracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblem0-1-knapsack" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblem0-1-knapsack" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
int W;
vector &lt;int&gt; val;
vector &lt;int&gt; w;
vector &lt;int&gt; take;
int max_sum_val = 0;
int min_sum_w = 0;
vector &lt;int&gt; ans_items_taken;

void backtrack (int last_taken, int sum_val, int sum_w) {
  if (sum_w &lt;= W and (sum_val &gt; max_sum_val or
      (sum_val == max_sum_val and sum_w &lt; min_sum_w))) {
    max_sum_val = sum_val;
    min_sum_w = sum_w;
    ans_items_taken = take;
  }
  for (int i = last_taken + 1; i &lt; n; i++) {
    take.push_back(i);
    backtrack(i, sum_val + val[i], sum_w + w[i]);
    take.pop_back();
  }
}

int main () {
  n = 3;
  W = 10;
  // item 1
  val.push_back(10);
  w.push_back(10);
  // item 2
  val.push_back(1);
  w.push_back(8);
  // item 3
  val.push_back(13);
  w.push_back(2);
  backtrack(-1, 0, 0);

  cout &lt;&lt; &quot;Take items&quot;;
  for (int item: ans_items_taken) {
    cout &lt;&lt; &#39; &#39; &lt;&lt; item + 1;
  }
  cout &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<div class="topic">
Permutations
</div>
<p>Do problem of generating all the permutations can also be easily computed using backtracking in <span class="math inline">\(O(n n!)\)</span></p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblempermutation" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblempermutation" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;bool&gt; used;
vector &lt;int&gt; permutation;

void print (const vector &lt;int&gt;&amp; p) {
  for (int elem: p) {
    cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
  }
  cout &lt;&lt; &#39;\n&#39;;
}

void backtrack () {
  if (permutation.size() == n) {
    print(permutation);
    return;
  }
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used[p_i] = false;
      permutation.pop_back();
    }
  }
}

int main () {
  n = 3;
  used.resize(n + 1, false);
  backtrack();
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>Here we are following these states:</p>
<div class="row text-center">
<p><img src="images/class-08/permutation.png" /></p>
</div>
<p>This image represents what is called the <strong>recursion tree</strong>. It show us how the function do the transitions.</p>
<p>Moreover, notice that we do not need to do something like this:</p>
<pre class="cpp"><code>.
.
.
  for (int p_i = 1; p_i &lt;= n; p_i++) {
    if (!used[p_i]) {
      vector &lt;bool&gt; used_previous = used;
      vector &lt;int&gt; permutation_previous = permutation;
      used[p_i] = true;
      permutation.push_back(p_i);
      backtrack();
      used = used_previous;
      permutation = permutation_previous;
    }
  }
.
.
.</code></pre>
<p>Because it will be heavier that the first solution and we know that:</p>
<ul>
<li>If previous of calling the recursion we ADD an element TO THE END of the vector, then after the recursion we must DELETE THE LAST element of the vector.</li>
<li>If previous of calling the recursion we SET TO TRUE an element, then after the recursion we must SET TO FALSE that element.</li>
<li>If previous of calling the recursion we ADD something, then after the recursion we must SUBTRACT something.</li>
<li>Following this logic, If previous of calling the recursion we DO ONE OPERATION, then after the recursion we must REVERSE that operation. If the operation is complicated we can just save a copy of the previous state, else we can try to reverse the operations.</li>
</ul>
<p>From all this one notice that if you are in your recursion in some <code>state</code> and you go to <code>state'</code>, then after returning of traversing the recursion tree of <code>state'</code> you expect to have some variables in the condition they were before traversing the recursion tree of <code>state'</code>. Understanding this idea is the key to implement backtracking solutions.</p>
<div class="topic">
Sudoku
</div>
<p>With backtracking it is easy to generate all possible movements in a game and choose the best movement.</p>
<p><strong>Problem:</strong></p>
<div class="row text-center">
<p><img src="images/class-08/sudoku1.png" /></p>
</div>
<p>Complete the above sudoku such that each number from 1 to 9 is found just once in each row, column and quadrant.</p>
<p><strong>Solution:</strong> We can just search all possible solutions using bactracking.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemsudoku" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemsudoku" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector &lt;vector &lt;int&gt;&gt; sudoku;
vector &lt;vector &lt;int&gt;&gt; sudoku_solved;
vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; quadrant;
int n;
int N;
bool found;

bool validInRow (int r, int d) {
  for (int c = 0; c &lt; N; c++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInCol (int c, int d) {
  for (int r = 0; r &lt; N; r++) {
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

bool validInQuadrant (int q, int d) {
  for (pair &lt;int, int&gt; pos: quadrant[q]) {
    int r = pos.first;
    int c = pos.second;
    if (sudoku[r][c] == d) return false;
  }
  return true;
}

// run this function for every 0 &lt;= r &lt; N and 0 &lt;= c &lt; N and you will get
// what this function does
int getQuadrant (int r, int c) {
  return (r / n) * n + (c / n);
}

void backtrack (int r, int c) {
  if (r == N) {
    found = true;
    sudoku_solved = sudoku;
    return;
  }
  if (found) {
    return;
  }
  int nc = (c + 1 == N) ? 0 : c + 1; // new column
  int nr = (c + 1 == N) ? r + 1 : r; // new row
  if (sudoku[r][c] != 0) {
    backtrack(nr, nc);
    return;
  } 
  for (int d = 1; d &lt;= 9; d++) {
    int quadrant = getQuadrant(r, c);
    if (validInRow(r, d) and
        validInCol(c, d) and
        validInQuadrant(getQuadrant(r, c), d)) {
      sudoku[r][c] = d;
      backtrack(nr, nc);
      sudoku[r][c] = 0;
    }
  }
}

void precomputation () {
  found = false;
  N = sudoku.size();
  n = 1;
  while ((n + 1) * (n + 1) &lt;= N) n++;
  // n = sqrt(N)
  quadrant.resize(N);
  for (int r = 0; r &lt; N; r++) {
    for (int c = 0; c &lt; N; c++) {
      quadrant[getQuadrant(r, c)].push_back({r, c});
    }
  }
}

void print (const vector &lt;vector &lt;int&gt;&gt;&amp; sudoku) {
  for (auto row: sudoku) {
    for (int elem: row) {
      cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; &#39;\n&#39;;
  }
}

int main () {
  sudoku = {{3, 0, 6, 5, 0, 8, 4, 0, 0},  
            {5, 2, 0, 0, 0, 0, 0, 0, 0},  
            {0, 8, 7, 0, 0, 0, 0, 3, 1},  
            {0, 0, 3, 0, 1, 0, 0, 8, 0},  
            {9, 0, 0, 8, 6, 3, 0, 0, 5},  
            {0, 5, 0, 0, 9, 0, 6, 0, 0},  
            {1, 3, 0, 0, 0, 0, 2, 5, 0},  
            {0, 0, 0, 0, 0, 0, 0, 7, 4},  
            {0, 0, 5, 2, 0, 6, 3, 0, 0}};
  precomputation();
  backtrack(0, 0);
  print(sudoku_solved);
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>With this code we get this solution:</p>
<div class="row text-center">
<p><img src="images/class-08/sudoku2.png" /></p>
</div>
<div class="topic">
N-queen problem
</div>
<p><strong><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">Problem:</a></strong> Given a chess board having <span class="math inline">\(N \times N\)</span> cells, you need to place <span class="math inline">\(N\)</span> queens on the board in such a way that no queen attacks any other queen.</p>
<p><span class="math display">\[1 \leq N \leq 10\]</span></p>
<p><strong>Remember:</strong> A queen can attack in a complete row, column or diagonal.</p>
<p><strong>Solution:</strong> We could try to place N queen in the <span class="math inline">\(N \times N\)</span> cells. In this way we may get <span class="math inline">\(\binom{N \times N}{N}\)</span> states to check. But for <span class="math inline">\(N = 8\)</span> we have that <span class="math inline">\(\binom{N \times N}{N} \approx 8B\)</span>, so we need a better approach.</p>
<p>We know that each queen should be in different columns (else they will be attacking each other). So we can generate these <span class="math inline">\(N^N\)</span> possible configurations and check if the conditions holds, but this solution may not be enough.</p>
<p>We know that each queen should be in different rows and columns. Then, the rows of the queens of a valid configuration are a permutation. The same holds for the columns. Thereby, we have <span class="math inline">\(N!\)</span> possible configurations to check. We can implement this idea using backtracking in this way:</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemn-queen" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemn-queen" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n;
vector &lt;pair &lt;int, int&gt;&gt; queen;
vector &lt;pair &lt;int, int&gt;&gt; solution;

bool valid (int r, int c) {
  for (auto pp: queen) {
    // if same row or same column or same diagonal
    if ((pp.first == r) or
        (pp.second == c) or
        (abs(r - pp.first) == abs(c - pp.second))) {
      return false;
    }
  }
  return true;
}

void backtrack (int r) {
  if (r == n) {
    solution = queen;
    return;
  }
  if (!solution.empty()) {
    return;
  }
  for (int c = 0; c &lt; n; c++) {
    if (valid(r, c)) {
      queen.push_back({r, c});
      backtrack(r + 1);
      queen.pop_back();
    }
  }
}

int main () {
  cin &gt;&gt; n;
  backtrack(0);
  if (solution.empty()) {
    cout &lt;&lt; &quot;NO\n&quot;;
    return (0);
  }
  vector &lt;vector &lt;int&gt;&gt; board(n, vector &lt;int&gt; (n, 0));
  for (auto pp: solution) {
    board[pp.first][pp.second] = 1;
  }
  cout &lt;&lt; &quot;YES\n&quot;;
  for (int r = 0; r &lt; n; r++) {
    for (int c = 0; c &lt; n; c++) {
      cout &lt;&lt; board[r][c] &lt;&lt; &quot; \n&quot;[c == n - 1];
    }
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
<p>For <span class="math inline">\(N = 4\)</span> the recursion tree of our solution is like this:</p>
<div class="row text-center">
<p><img src="images/class-08/n-queen.png" /></p>
</div>
<p>Image taken from <a href="http://jeffe.cs.illinois.edu/teaching/algorithms/">Jeff Erickson - Algorithms - Chapter 2: Backtracking</a>.</p>
<p>The complexity of the above solution comes from the equation:</p>
<p><span class="math display">\[T_n = n \cdot T_{n - 1} + O(n)\]</span> <span class="math display">\[\to T_n = O(n!)\]</span></p>
<p>Then, our solution has complexity <span class="math inline">\(O(n!)\)</span>.</p>
<p>Recommended readings:</p>
<ul>
<li><a href="https://www.hackerearth.com/practice/basic-programming/recursion/recursion-and-backtracking/tutorial/">HackerEarth - Recursion and Backtracking</a></li>
<li>Competitive Programming 3, section 3.2.2, 8.2.1 and 8.2.2.</li>
<li><a href="https://www.geeksforgeeks.org/backtracking-algorithms/">GeekForGeeks - Backtracking Algorithms</a></li>
</ul>
<p>You may also be interested in watching the documental of AlphaGo. <a href="https://youtu.be/8tq1C8spV_g">Here</a> is the trailer.</p>
<div class="topic">
Contest
</div>
<p>You can find the contest <a href="https://vjudge.net/contest/354334">here</a>.</p>
<p>The solutions will be uploaded after the contest.</p>

<footer>
  <p>Copyright &copy; 2020. Competitive Programming UTEC</p>
</footer>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
