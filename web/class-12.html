<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Class 12: Divide and Conquer II</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
<!--Let browser know website is optimized for mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<!-- Gallery library -->
<link rel="stylesheet" type="text/css" href="lib/lightbox.min.css">
<!-- p5.js library -->
<script src="lib/p5.min.js"></script>
<!-- animation -->
<script src="animations/class-12/Rectangle.js"></script>
<script src="animations/class-12/Cell.js"></script>
<script src="animations/class-12/sketch.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 54px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h2 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h3 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h4 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h5 {
  padding-top: 59px;
  margin-top: -59px;
}
.section h6 {
  padding-top: 59px;
  margin-top: -59px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">



<div class="wrapper">

<!-- Sidebar Holder -->
<nav id="sidebar">
<div class="sidebar-header">
  <h3 style="text-align: left;">
    <a style="text-decoration: none;"href="./index.html">
      Competitive programming UTEC
    </a>
  </h3>
  <strong>
    <a style="text-decoration: none;"href="./index.html">
    CP-UTEC
    </a>
  </strong>
</div>

<div id="dismiss-left">
  <i class="fa fa-arrow-left"></i>
</div>

<div id="dismiss-right">
  <i class="fa fa-arrow-right"></i>
</div>

<ul class="list-unstyled components">

  <div class="line"></div>
  
  <li id="index-page">
    <a href="./index.html">
      Home
    </a>
  </li>

  <div class="line"></div>

  <li id="schedule-page">
    <a href="./schedule.html">
      Schedule
    </a>
  </li>

  <div class="line"></div>

  <li id="classes-page-expanded">
    <a id="classes" href="#all-classes" data-toggle="collapse"
      aria-expanded="false">
      Classes
    </a>
    <ul class="collapse list-unstyled" id="all-classes">
      <li id="class-01">
        <a href="./class-01.html">1. Introduction</a>
      </li>
      <li id="class-02">
        <a href="./class-02.html">2. Asymptotic Analysis</a>
      </li>
      <li id="class-03">
        <a href="./class-03.html">3. Standard Template Library</a>
      </li>
      <li id="class-04">
        <a href="./class-04.html">4. Complete Search I</a>
      </li>
      <li id="class-05">
        <a href="./class-05.html">5. Complete Search II</a>
      </li>
      <li id="class-06">
        <a href="./class-06.html">6. Complete Search III</a>
      </li>
      <li id="class-07">
        <a href="./class-07.html">7. Complete Search IV</a>
      </li>
      <li id="class-08">
        <a href="./class-08.html">8. Complete Search V</a>
      </li>
      <li id="class-09">
        <a href="./class-09.html">9. Contest I</a>
      </li>
      <li id="class-10">
        <a href="./class-10.html">10. Contest UTEC-UNI-UPC I</a>
      </li>
      <li id="class-11">
        <a href="./class-11.html">11. Divide and Conquer I</a>
      </li>
      <li id="class-12">
        <a href="./class-12.html">12. Divide and Conquer II</a>
      </li>
      <li id="class-13">
        <a href="./class-13.html">13. Game Theory I</a>
      </li>
      <li id="class-14">
        <a href="./class-14.html">14. Game Theory II</a>
      </li>
      <li id="class-15">
        <a href="./class-15.html">15. Contest II</a>
      </li>
      <li id="class-16">
        <a href="./class-16.html">16. Contest UTEC-UNI-UPC II</a>
      </li>
      <li id="class-17">
        <a href="./class-17.html">17. Graph Theory I</a>
      </li>
    </ul>
  </li>

  <div class="line"></div>

  <li id="classes-page-not-expanded">
    <a href="./classes.html">
      Classes
    </a>
  </li>

  <div class="line"></div>

  <li id="daily-problem-page">
    <a href="./daily-problem.html">
      Daily problem
    </a>
  </li>

  <div class="line"></div>

  <li id="gallery-page">
    <a href="./gallery.html">
      Gallery
    </a>
  </li>

  <div class="line"></div>

</ul>


<!--
<ul class="list-unstyled">
  <li>
    <a href="https://www.utec.edu.pe/" target="_blank" class="logo">
      <img src="images/page/utec-logo.png" alt="UTEC logo">
    </a>
  </li>
</ul>
-->
</nav>

<div id="expand-icon-right">
  <i class="fa fa-angle-right"></i>
</div>

<div id="expand-icon-left">
  <i class="fa fa-angle-left"></i>
</div>

<!-- Page Content Holder -->
<div id="content">
<script>
$(".main-container")
  .removeClass("main-container")
  .removeClass("container-fluid")
</script>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Class 12: Divide and Conquer II</h1>
<h4 class="date">02-19-2020</h4>

</div>


<blockquote>
<p>“Don’t repeat yourself”</p>
</blockquote>
<div class="topic">
Generalized binary search
</div>
<p>When we are doing binary search we are basically finding a function <span class="math inline">\(f: \mathbb{D} \to \{0, 1\}\)</span>. We are finding a function that maps the elements of a set <span class="math inline">\(\mathbb{D}\)</span> to <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> (can be seen as false or true respectively) and <span class="math inline">\(f\)</span> <strong>is always a monotone</strong> function (non-increasing or non-decreasing).</p>
<p>For example, if we have the array <span class="math inline">\(A = \{b_0, b_1, b_2, \dots, b_{n - 1}\}\)</span> and we are going to do queries over the array to determine whether a number is in <span class="math inline">\(A\)</span> or not we can do these definitions:</p>
<p><span class="math display">\[\mathbb{D} = \{0, 1, 2, \dots, n\}\]</span> <span class="math display">\[f_p(x) = [p \leq A[x]]\]</span></p>
<p>That is, <span class="math inline">\(f = f_p\)</span> will be a function that will indicate if <span class="math inline">\(p \leq A[x]\)</span> for <span class="math inline">\(x \in [0, n)\)</span> and as <span class="math inline">\(f\)</span> must be monotone we need to sort <span class="math inline">\(A\)</span> (<strong>why?</strong>). Now, with these definitions and asumming <span class="math inline">\(A\)</span> is sorted, <span class="math inline">\(f\)</span> may looks something like this.</p>
<div class="row text-center">
<p><img src="images/class-12/monotone-function.png" /></p>
</div>
<p>Then, if <span class="math inline">\(p\)</span> is in the array <span class="math inline">\(A\)</span>, it must hold that <span class="math inline">\(A[z] = p\)</span>, so now our problem is to find the first element where <span class="math inline">\(f(x) = 1\)</span> and we can compute it using divide and conquer.</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

// Returns true if p is in A in O(n)
bool brute_force (const vector &lt;int&gt;&amp; A, int p) {
  for (int elem: A) {
    if (elem == p) return true;
  }
  return false;
}

// Returns true if p is in A in O(log n)
bool divide_and_conquer (const vector &lt;int&gt;&amp; A, int p) {
  int l = 0, r = A.size() - 1;
  while (l != r) {
    int m = (l + r) &gt;&gt; 1; // = (l + r) / 2
    bool f_p = (p &lt;= A[m]);
    if (f_p) {
      r = m;
    } else {
      l = m + 1;
    }
  }
  int z = l;
  return (A[z] == p);
}

int main () {
  // To get &#39;good&#39; random numbers
  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  // Create A with n random values
  int n = 1000;
  int min_value = -1e6;
  int max_value = 1e6;
  vector &lt;int&gt; A(n);
  for (int&amp; elem: A) {
    elem = uniform_int_distribution &lt;int&gt; (min_value, max_value)(rng);
  }
  sort(begin(A), end(A));
  // Check q queries
  int q = 1000;
  for (int i = 0; i &lt; q; i++) {
    int p = uniform_int_distribution &lt;int&gt; (min_value, max_value)(rng);
    bool ret1 = brute_force(A, p);
    bool ret2 = divide_and_conquer(A, p);
    if (ret1 != ret2) {
      cout &lt;&lt; &quot;Something is wrong!\n&quot;;
      return (-1);
    }
  }
  cout &lt;&lt; &quot;OK!\n&quot;;
  return (0);
}</code></pre>
<p>What would have changed if <span class="math inline">\(f_p(x) = [A[x] \leq p]\)</span> ?</p>
<p>The idea of defining the set <span class="math inline">\(\mathbb{D}\)</span> and the <strong>mononote</strong> function <span class="math inline">\(f\)</span> can be used in a great variety of problems. For example in <a href="https://codeforces.com/contest/1201/problem/C">this problem</a>.</p>
<p>Here let <span class="math inline">\(median\)</span> be the median of the original array, then we know that the maximum median we can get must be in in <span class="math inline">\([median, median + k]\)</span>, so <span class="math inline">\(\mathbb{D} = [median, median + k]\)</span> and let <span class="math inline">\(f\)</span> be defined like this:</p>
<p><span class="math inline">\(f(x) = [\)</span> can we obtain median x in at most k operations? <span class="math inline">\(]\)</span></p>
<p>Let <span class="math inline">\(y\)</span> be the position of the median, then if we have:</p>
<p><span class="math display">\[a_0, a_1, a_2, \dots, a_y, a_{y + 1}, \dots, a_{n - 1}\]</span></p>
<p>And we want <span class="math inline">\(x\)</span> as the new median in the minimum number of operations, then we need to make <span class="math inline">\(x \leq a_i, \forall \, y \leq i \leq n\)</span>. (<strong>why?</strong>). Moreover, there is a point <span class="math inline">\(z\)</span> such that:</p>
<p><span class="math display">\[f(i) = 1 \quad \forall i \in [median, z]\]</span> <span class="math display">\[f(i) = 0 \quad \forall i \in [z + 1, median + 1]\]</span></p>
<p>So <span class="math inline">\(f\)</span> is monotone and our answer is <span class="math inline">\(z\)</span>. The we can implement the following solution:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int main () {
  int n, k;
  cin &gt;&gt; n &gt;&gt; k;
  vector &lt;int&gt; a(n);
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
  sort(begin(a), end(a));
  int y = n / 2;
  ll median = a[y];
  ll l = median, r = median + k;
  while (l != r) {
    ll m = (l + r + 1) / 2;
    ll n_operations = 0;
    for (int i = y; i &lt; n; i++) {
      if (a[i] &lt; m) {
        n_operations += m - a[i];
      }
    }
    if (l &lt; 0) break;
    if (n_operations &lt;= k) {
      l = m;
    } else {
      r = m - 1;
    }
  }
  int z = l;
  cout &lt;&lt; z &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
<p>In these examples we have defined <span class="math inline">\(\mathbb{D} \subset \mathbb{Z}\)</span> but we may have, for example, <span class="math inline">\(\mathbb{D} \subset \mathbb{R}\)</span>.</p>
<p>Moreover, if you have problems determining how to compute <span class="math inline">\(m\)</span>, always think of what do you want to do when <span class="math inline">\(l + 1 = r\)</span>. You want that <span class="math inline">\(m = l \lor m = r\)</span> and then you will find if you need to compute <span class="math inline">\(m = (l + r) / 2\)</span> or <span class="math inline">\(m = (l + r + 1) / 2\)</span> and how to update <span class="math inline">\(l, r\)</span>.</p>
<div class="topic">
Ternary search
</div>
<p>Let <span class="math inline">\(f(x)\)</span> be a unimodal function in <span class="math inline">\([l, r]\)</span>, that is, it holds</p>
<ul>
<li>The function stricly increases first, reaches a maximum (at a single point or over an interval) and then stricly decreases.</li>
</ul>
<p>Or</p>
<ul>
<li>The function stricly decreases first, reaches a minimum (at a single point or over an interval) and then stricly increases.</li>
</ul>
<p>Then, assuming the first scenario (the second one is analogous), how can we find the maximum value of <span class="math inline">\(f(x) \mid x \in [l, r]\)</span> ?</p>
<p>For simplicity, let <span class="math inline">\([l, r] \subset \mathbb{R}\)</span>.</p>
<p>Let <span class="math inline">\(l \leq m_1 \leq m_2 \leq r\)</span></p>
<p>Initially you know that the maximum is in <span class="math inline">\([l, r]\)</span> and by the trichotomy property there are three cases:</p>
<ul>
<li><span class="math inline">\(f(m_1) = f(m_2)\)</span>. Then we are done</li>
<li><span class="math inline">\(f(m_1) &lt; f(m_2)\)</span>. Then the answer must be in <span class="math inline">\([m_1, r]\)</span> (<strong>why?</strong>).</li>
<li><span class="math inline">\(f(m_1) &gt; f(m_2)\)</span>. Then the answer must be in <span class="math inline">\([l, m_2]\)</span> (<strong>why?</strong>).</li>
</ul>
<p>So, each time we can reduce the interval where the answer must be. In we split the interval <span class="math inline">\([l, r]\)</span> in three parts, then we will find the answer in <span class="math inline">\(O(\log n)\)</span> and we may have:</p>
<p><span class="math display">\[m_1 = \frac{2 \cdot l + r}{3}\]</span> <span class="math display">\[m_2 = \frac{l + 2 \cdot r}{3}\]</span></p>
<p>The idea also works when <span class="math inline">\([l, r] \subset \mathbb{Z}\)</span> with some little modifications, but in these cases it is easier to use binary search because we just need to find the first <span class="math inline">\(x\)</span> where <span class="math inline">\(f(x) \leq f(x + 1)\)</span>.</p>
<div id="convex-functions" class="section level3">
<h3>Convex functions</h3>
<p>We say that a real-valued function is convex if the line segment between any two points on the graph of the function lies above or on the graph. More formally, we have:</p>
<p><strong>Definition 1:</strong> A set <span class="math inline">\(X\)</span> is convex if <span class="math inline">\(\forall x_1, x_2 \in X, \forall t \in [0, 1]: t \cdot x_1 + (1 - t) \cdot x_2 \in X\)</span>.</p>
<p><strong>Definition 2:</strong> Let <span class="math inline">\(f: X \to \mathbb{R}\)</span> be a function where <span class="math inline">\(X\)</span> is a convex set, then <span class="math inline">\(f\)</span> is convex if <span class="math inline">\(\forall x_1, x_2 \in X, \forall t \in [0, 1]: f(t \cdot x_1 + (1 - t) \cdot x_2) \leq t f(x_1) + (1 - t) \cdot f(x_2)\)</span>.</p>
<p>Moreover, we have some interesting properties. Let <span class="math inline">\(f, g\)</span> be convex functions, then we have:</p>
<ul>
<li><span class="math inline">\(f + g\)</span> is convex</li>
<li><span class="math inline">\(\max(f, g)\)</span> is convex</li>
</ul>
<p>Some examples of convex function are:</p>
<ul>
<li><span class="math inline">\(f(x) = |x|\)</span></li>
<li><span class="math inline">\(f(x) = x^2\)</span></li>
<li><span class="math inline">\(f(x) = e^x\)</span></li>
</ul>
<p>And what is interesting of convex functions is that we can apply ternary search on them to find its minimum value.</p>
</div>
<div id="examples" class="section level3">
<h3>Examples</h3>
<p>We can use ternary search to find the minimum of:</p>
<ul>
<li><span class="math inline">\(f(x) = |a_1 - x| + |a_2 - x| + \dots + |a_n - x|\)</span></li>
<li><span class="math inline">\(f(x) = (a_1 - x)^2 + (a_2 - x)^2 + \dots + (a_n - x)^2\)</span></li>
</ul>
<p>Now, try solving the problem at the end of <a href="https://www.hackerearth.com/practice/algorithms/searching/ternary-search/tutorial/">this tutorial</a> to apply what we have learned.</p>
<p>So far we have study binary and ternary search, yet the D&amp;C paradigm does not reduce only to this. Next, we will show you two more scenarios where D&amp;C paradigm comes in handy.</p>
<div class="topic">
Merge sort
</div>
</div>
<div id="subproblem-merge-two-sorted-arrays" class="section level3">
<h3>Subproblem: merge two sorted arrays</h3>
<p>Let</p>
<p><span class="math display">\[a = [a_1, a_2, \dots, a_n]\]</span> <span class="math display">\[b = [b_1, b_2, \dots, b_m]\]</span></p>
<p>be two sorted arrays. How can we get a sorted array with the elements of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> ?</p>
<p>The most naive approach would be to create an array with its elements and sort it, something like this:</p>
<pre class="cpp"><code>vector &lt;int&gt; c;
for (int elem: a) c.push_back(elem);
for (int elem: b) c.push_back(elem);
sort(begin(c), end(c));</code></pre>
<p>But, this solution is <span class="math inline">\(O((n + m) \log (n + m))\)</span> and we are not using the fact that both arrays are sorted. But, we can notice that as both array are sorted, the minimum element of <span class="math inline">\(c\)</span> must be <span class="math inline">\(a_1\)</span> or <span class="math inline">\(b_1\)</span>. Next, out next minimum element must be in <span class="math inline">\((a[2:n], b[1:m])\)</span> or in <span class="math inline">\((a[1:n], b[2:m])\)</span>. That is, we can iterate both arrays in such a way the we are always getting the next minimum element of <span class="math inline">\(c\)</span>, therefore we can get <span class="math inline">\(c\)</span> sorted in <span class="math inline">\(O(n + m)\)</span> in this way:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

// To get &#39;good&#39; random numbers
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int min_value = -1e6;
int max_value = 1e6;

// return a random integer in [l, r]
int random (int l, int r) {
  return uniform_int_distribution &lt;int&gt; (l, r)(rng);
}

vector &lt;int&gt; get_random_array (int n) {
  vector &lt;int&gt; ret(n);
  for (int&amp; elem: ret) {
    elem = random(min_value, max_value);
  }
  return ret;
}

vector &lt;int&gt; merge (const vector &lt;int&gt;&amp; a, const vector &lt;int&gt;&amp; b) {
  const int INF = INT_MAX;
  vector &lt;int&gt; A = a;
  vector &lt;int&gt; B = b;
  int n = A.size();
  int m = B.size();
  // to simplify the implementation
  A.push_back(INF);
  B.push_back(INF);
  int it1 = 0, it2 = 0;
  vector &lt;int&gt; c;
  while (it1 &lt; n or it2 &lt; m) {
    if (A[it1] &lt;= B[it2]) {
      c.push_back(A[it1]);
      it1++;
    } else {
      c.push_back(B[it2]);
      it2++;
    }
  }
  return c;
}

int main () {
  for (int test = 0; test &lt; 1000; test++) {
    int n = random(1, 1000);
    int m = random(1, 1000);
    vector &lt;int&gt; a = get_random_array(n);
    sort(begin(a), end(a));
    vector &lt;int&gt; b = get_random_array(m);
    sort(begin(b), end(b));
    // naive merge
    vector &lt;int&gt; c;
    for (int elem: a) c.push_back(elem);
    for (int elem: b) c.push_back(elem);
    sort(begin(c), end(c));
    if (c != merge(a, b)) {
      cout &lt;&lt; &quot;Something is wrong!\n&quot;;
      return (-1);
    }
  }
  cout &lt;&lt; &quot;OK!\n&quot;;
  return (0);
}</code></pre>
</div>
<div id="merge-sort" class="section level3">
<h3>Merge sort</h3>
<p>The idea of merge sort is very simple:</p>
<p>Let <code>vector &lt;int&gt; merge_sort(vector &lt;int&gt;&amp; a)</code> be a function that returns the array <code>a</code> sorted, then we can define it recursively, we can split the array <code>a</code> in two disjoint arrays (the optimal is to split it in the middle), sort each new array and then merge then efficiently using the function of the previous subsection. We can implement it in this way:</p>
<pre class="cpp"><code>...
vector &lt;int&gt; merge_sort (const vector &lt;int&gt;&amp; a) {
  if (a.size() &lt;= 1) return a;
  int m = a.size() / 2;
  vector &lt;int&gt; left;
  for (int i = 0; i &lt; m; i++) left.push_back(a[i]);
  vector &lt;int&gt; right;
  for (int i = m; i &lt; a.size(); i++) right.push_back(a[i]);
  vector &lt;int&gt; x = merge_sort(left);
  vector &lt;int&gt; y = merge_sort(right);
  return merge(x, y);
};
...</code></pre>
<p><a href="./code/class-12/merge-sort.cpp">Full code</a></p>
<p>And we can also implement merge sort in a simple way using the STL in this way:</p>
<pre class="cpp"><code>vector &lt;int&gt; merge_sort (const vector &lt;int&gt;&amp; a) {
  if (a.size() &lt;= 1) return a;
  int m = a.size() / 2;
  vector &lt;int&gt; left(begin(a), begin(a) + m);
  vector &lt;int&gt; right(begin(a) + m, end(a));
  vector &lt;int&gt; x = merge_sort(left);
  vector &lt;int&gt; y = merge_sort(right);
  vector &lt;int&gt; ret;
  std::merge(begin(x), end(x),
             begin(y), end(y),
             std::back_inserter(ret));
  return ret;
};</code></pre>
<p><a href="./code/class-12/merge-sort-stl.cpp">Full code</a></p>
<p><strong>Can we improve the above implementation?</strong></p>
<p>Now, in order to get the complexity of this algorithm notice that</p>
<ul>
<li>We need to run <span class="math inline">\(2^0\)</span> merge function in <span class="math inline">\(O(n / 2^0)\)</span></li>
<li>We need to run <span class="math inline">\(2^1\)</span> merge functions in <span class="math inline">\(O(n / 2^1)\)</span></li>
<li>We need to run <span class="math inline">\(2^2\)</span> merge functions in <span class="math inline">\(O(n / 2^2)\)</span></li>
<li>We need to run <span class="math inline">\(2^4\)</span> merge functions in <span class="math inline">\(O(n / 2^3)\)</span> …</li>
<li>We need to run <span class="math inline">\(2^{\log n}\)</span> merge functions in <span class="math inline">\(O(n / 2^{\log n})\)</span></li>
</ul>
<p>We can see it in this way:</p>
<div class="row text-center">
<p><img src="images/class-12/merge-sort.png" /></p>
</div>
<p>So, basically, the number of operations that merge sort does (i.e its complexity) is the area of a rectangle with width <span class="math inline">\(O(n)\)</span> and height <span class="math inline">\(O(\log n)\)</span>, then the complexity of merge sort is <span class="math inline">\(O(n \log n)\)</span>.</p>
<div class="topic">
Inductive constructions
</div>
<p>In some mathematical induction proofs we use disjoint smaller cases of a problem to solve a larger one (usually doing some kind of constructions). For example:</p>
<p><strong>Problem:</strong> In a square grid of side length <span class="math inline">\(2^n\)</span>, one unit square is blocked (represented by coloring it black). Your task is to cover the remaining <span class="math inline">\(4^n - 1\)</span> squares with <em>triominos</em>, L-shaped tiles consisting of three squares in the following fashion. The triominos can be rotated by any multiple of <span class="math inline">\(90\)</span> degrees. Moreover, the triominos may not overlap each other, nor cover anything outside the grid. Given <span class="math inline">\(1 \leq n \leq 8, 0 \leq x &lt; 2^n \land  0 \leq y &lt; 2^n\)</span>. The black square has coordinates <span class="math inline">\((x, y)\)</span>. Find a valid tiling of the grid.</p>
<p>These are the four valid rotations of a triomino.</p>
<div class="row text-center img-border">
<p><img src="images/class-12/tiling1.png" /></p>
</div>
<p>This is a possible tiling for <span class="math inline">\(n = 2\)</span>.</p>
<div class="row text-center img-border">
<p><img src="images/class-12/tiling2.png" /></p>
</div>
<ul>
<li>The problem and images where taken from <a href="https://www.csc.kth.se/~jsannemo/slask/main.pdf">Principles of Algorithmic Problem Solving, secion 10.1 - page 170</a>.</li>
</ul>
<p>First of all let’s prove that there is always a valid tiling by induction:</p>
<ul>
<li><p>If <span class="math inline">\(n = 1\)</span> no matter where that black square is, we can always fill the grid with one of the valid rotations of a triomino.</p></li>
<li><p>If <span class="math inline">\(n &gt; 1\)</span> we can divide the grid in four grids of size <span class="math inline">\(2^{n - 1}\)</span>, we can identify in which new grid the black square is and put a triomino in such a way that it have 1 of its square in one different grid and is not in the grid where the black square is. Then, we have to solve the same problem in four smaller instances, but by the inductive hyphotesis we already have the answer for them. This construction idea can be seen in this image:</p>
<div class="row text-center">
<p><img src="images/class-12/triomino.png" /></p>
</div></li>
</ul>
<p>And we can use the construction used in the above proof to implement a solution like this:</p>
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int TOP_LEFT = 0;
const int TOP_RIGHT = 1;
const int BOTTON_LEFT = 2;
const int BOTTON_RIGHT = 3;

struct Rectangle {
  int x, y;
  int len;
  pair &lt;int, int&gt; new_black;
  Rectangle () {}
  Rectangle (int x, int y, int len, int position):
    x(x), y(y), len(len) {
    switch (position) {
      case TOP_LEFT:
        new_black = {x, y}; 
        break;
      case TOP_RIGHT:
        new_black = {x, y + len - 1};
        break;
      case BOTTON_LEFT:
        new_black = {x + len - 1, y};
        break;
      case BOTTON_RIGHT:
        new_black = {x + len - 1, y + len - 1};
        break;
      default:
        break;
    }
    
  }
  bool has (pair &lt;int, int&gt; black) {
    return x &lt;= black.first and black.first &lt; x + len and
           y &lt;= black.second and black.second &lt; y + len;
  }
};

char cur_letter = &#39;a&#39;;

void update_cur_letter () {
  if (cur_letter == &#39;z&#39;) cur_letter = &#39;a&#39;;
  else cur_letter++;
}

void solve (Rectangle rect, pair &lt;int, int&gt; black, vector &lt;string&gt;&amp; grid) {
  if (rect.len == 1) return;
  vector &lt;Rectangle&gt; sector;
  int m = rect.len / 2;
  int x = rect.x;
  int y = rect.y;
  sector.emplace_back(x + 0, y + 0, m, BOTTON_RIGHT);
  sector.emplace_back(x + 0, y + m, m, BOTTON_LEFT);
  sector.emplace_back(x + m, y + 0, m, TOP_RIGHT);
  sector.emplace_back(x + m, y + m, m, TOP_LEFT);
  char ch = cur_letter;
  update_cur_letter();
  for (auto s: sector) {
    if (s.has(black)) {
      solve(s, black, grid);
    } else {
      grid[s.new_black.first][s.new_black.second] = ch;
      solve(s, s.new_black, grid);
    }
  }
}

int main () {
  int n, x, y;
  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
  assert (1 &lt;= n and n &lt; 8);
  int m = (1 &lt;&lt; n);
  assert (0 &lt;= x &lt; m);
  assert (0 &lt;= y &lt; m);
  vector &lt;string&gt; grid(m, string(m, &#39; &#39;));
  grid[x][y] = &#39;#&#39;;
  solve(Rectangle(0, 0, m, -1), pair &lt;int, int&gt;(x, y), grid);
  for (string&amp; row: grid) cout &lt;&lt; row &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
<p>Here is an animation of the above problem. You can interact with it:</p>
<form class="range-field my-4 w-50">
n: <input id="parameter_n" type="range" min="1" max="7" value="4" step="1" />
</form>
<form class="range-field my-4 w-50">
speed: <input id="speed" type="range" min="1" max="7" value="4" step="1" />
</form>
<div id="sketch-holder" class="img-border">

</div>
<p>Recommended readings:</p>
<ul>
<li><a href="https://www.csc.kth.se/~jsannemo/slask/main.pdf">Principles of Algorithmic Problem Solving, section 10.1 and 10.2</a></li>
<li><a href="https://cp-algorithms.com/num_methods/ternary_search.html">E-maxx - Ternary search</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/searching/linear-search/tutorial/">HackerEarth - Searching [Tutorial]</a></li>
<li><a href="https://nbviewer.jupyter.org/github/TISparta/pcuni-2019/blob/master/clase-16/clase-16.ipynb">PCUNI-2019 clase 16</a></li>
<li><a href="https://www.topcoder.com/binary-stride-a-variant-on-binary-search/">Topcoder - Binary stride a variant on binary search</a></li>
</ul>
<div id="contest" class="topic">
Contest
</div>
<p>You can find the contest <a href="https://vjudge.net/contest/359160">here</a>.</p>
<!-- Begins problem A -->
<div id="A" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
A: Creative Snap
</p>
</div>
<!-- begin body -->
<div id="collapseProblemA" class="collapse">
<div class="card-body solution-body">
<h3 id="creative-snap"><a href="https://codeforces.com/problemset/problem/1111/C" target="_blank">Creative Snap</a></h3>
<p>Read carefully the problem, it is basically describing what to implement.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemA" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemA" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int n, k, A, B;
vector &lt;int&gt; arr;

int get (int l, int r) {
  if (arr.back() &lt; l) return 0;
  if (arr.front() &gt; r) return 0;
  int it1 = lower_bound(begin(arr), end(arr), l) - begin(arr);
  int it2 = upper_bound(begin(arr), end(arr), r) - begin(arr) - 1;
  return it2 - it1 + 1;
}

ll dc (int l, int r) {
  int cnt = get(l, r);
  if (cnt == 0) return A;
  if (l == r) return B * cnt * 1;
  int m = (l + r) &gt;&gt; 1;
  return min(1LL * B * cnt * (r - l + 1), dc(l, m) + dc(m + 1, r));
}

int main () {
  ios::sync_with_stdio(false);
  cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B;
  arr.resize(k);
  for (int i = 0; i &lt; k; i++) cin &gt;&gt; arr[i];
  sort(begin(arr), end(arr));
  cout &lt;&lt; dc(1, (1 &lt;&lt; n)) &lt;&lt; endl;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem A -->
<!-- Begins problem B -->
<div id="B" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
B: Code For 1
</p>
</div>
<!-- begin body -->
<div id="collapseProblemB" class="collapse">
<div class="card-body solution-body">
<h3 id="code-for-1"><a href="https://codeforces.com/contest/768/problem/B" target="_blank">Code For 1</a></h3>
<p>You just need to count the number of element in <span class="math inline">\([l, r]\)</span> that are one in the final array and we can use divide and conquer to generate it.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemB" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemB" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef pair &lt;ll, ll&gt; pll;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;
typedef vector &lt;pii&gt; vpii;
typedef vector &lt;pll&gt; vpll;


int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  ll n, l, r;
  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
  ll m = n;
  ll k = 0;
  while (m) {
    k++;
    m /= 2;
  }
  function &lt;int(ll,ll,ll)&gt; dc = [&amp;] (ll n, ll x, ll y) -&gt; int {
    if (not (max(x, l) &lt;= min(r, y))) return 0;
    ll m = (x + y) / 2;
    ll ret = 0;
    if (l &lt;= m and m &lt;= r and n &amp; 1) ret = 1;
    ret += dc(n / 2, x, m - 1);
    ret += dc(n / 2, m + 1, y);
    return ret;
  };
  cout &lt;&lt; dc(n, 1, (1LL &lt;&lt; k) - 1) &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem B -->
<!-- Begins problem C -->
<div id="C" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
C: Race Time!
</p>
</div>
<!-- begin body -->
<div id="collapseProblemC" class="collapse">
<div class="card-body solution-body">
<h3 id="race-time"><a href="https://www.codechef.com/problems/AMCS03" target="_blank">Race Time!</a></h3>
<p>We have that <span class="math inline">\(f\)</span> is a convex function, then we can find the minimum point using ternary search.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemC" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemC" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef pair &lt;ll, ll&gt; pll;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;
typedef vector &lt;pii&gt; vpii;
typedef vector &lt;pll&gt; vpll;

int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  int n, k;
  cin &gt;&gt; n &gt;&gt; k;
  vector &lt;pll&gt; arr(n);
  for (auto&amp; pp: arr) cin &gt;&gt; pp.first &gt;&gt; pp.second;
  double l = 0, r = k;
  auto eval = [&amp;] (double t) {
    vector &lt;double&gt; val(n);
    for (int i = 0; i &lt; n; i++) {
      val[i] = arr[i].first * t + arr[i].second;
    }
    return *max_element(all(val)) - *min_element(all(val));
  };
  for (int it = 0; it &lt; 100; it++) {
    double ll = (2 * l + r) / 3.0;
    double rr = (l + 2 * r) / 3.0;
    if (eval(ll) &lt; eval(rr)) r = rr;
    else l = ll;
  }
  cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; eval(l) &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem C -->
<!-- Begins problem D -->
<div id="D" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
D: Trick or Treat
</p>
</div>
<!-- begin body -->
<div id="collapseProblemD" class="collapse">
<div class="card-body solution-body">
<h3 id="trick-or-treat"><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3349" target="_blank">Trick or Treat</a></h3>
<p>The function we want to minimize is convex, then we can apply ternary search.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemD" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemD" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef pair &lt;ll, ll&gt; pll;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;
typedef vector &lt;pii&gt; vpii;
typedef vector &lt;pll&gt; vpll;

int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  int n;
  while (cin &gt;&gt; n, n != 0) {
    vector &lt;pair &lt;double, double&gt;&gt; arr(n);
    for (auto&amp; pp: arr) cin &gt;&gt; pp.first &gt;&gt; pp.second;
    auto eval = [&amp;] (double x) {
      // point (x, 0)
      double ret = 0;
      for (auto pp: arr) {
        double dis = sqrt(pow(pp.first - x, 2) + pow(pp.second, 2));
        ret = max(ret, dis);
      }
      return ret;
    };
    double l = -1e9, r = 1e9;
    for (int it = 0; it &lt; 100; it++) {
      double ll = (2 * l + r) / 3.0;
      double rr = (l + 2 * r) / 3.0;
      if (eval(ll) &lt; eval(rr)) r = rr;
      else l = ll;
    }
    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; eval(l) &lt;&lt; &#39;\n&#39;;
  }
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem D -->
<!-- Begins problem E -->
<div id="E" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
E: Energy exchange
</p>
</div>
<!-- begin body -->
<div id="collapseProblemE" class="collapse">
<div class="card-body solution-body">
<h3 id="energy-exchange"><a href="https://codeforces.com/contest/68/problem/B" target="_blank">Energy exchange</a></h3>
<p>Let <span class="math inline">\(x\)</span> be the final amount of energy, then you can compute the amount of enery that must be transfered and if it is non-negative, then it is possible to get that final amount of energy. Therefore, we can use binary search to get the maximum possible amount of energy.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemE" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemE" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef pair &lt;ll, ll&gt; pll;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;
typedef vector &lt;pii&gt; vpii;
typedef vector &lt;pll&gt; vpll;

int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  int n, k;
  cin &gt;&gt; n &gt;&gt; k;
  vi arr(n);
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i];
  auto check = [&amp;] (double x) {
    double ret = 0;
    for (int elem: arr) {
      if (x &lt;= elem) ret += 1.0 * (100.0 - k) * (elem - x) / 100.0;
      else ret += elem - x;
    }
    return (ret &gt;= 0);
  };
  double l = 0;
  double r = *max_element(all(arr));
  for (int it = 0; it &lt; 100; it++) {
    double m = (l + r) / 2.0;
    if (check(m)) l = m;
    else r = m;
  }
  cout &lt;&lt; fixed &lt;&lt; setprecision(12) &lt;&lt; l &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem E -->
<!-- Begins problem F -->
<div id="F" class="card">
<div class="collapsed solution-title" type="button" data-toggle="collapse" data-target="#collapseProblemF" aria-expanded="false" aria-controls="collapseTwo">
<!-- title -->
<i class="fas fa-caret-right"></i>
<p class="title">
F: Monitor
</p>
</div>
<!-- begin body -->
<div id="collapseProblemF" class="collapse">
<div class="card-body solution-body">
<h3 id="monitor"><a href="https://codeforces.com/problemset/problem/16/C" target="_blank">Monitor</a></h3>
<p>Let <span class="math inline">\(g = \gcd(x, y)\)</span>, <span class="math inline">\(x&#39; = x / g\)</span>, <span class="math inline">\(y&#39; = y / g\)</span>, then we have to find <span class="math inline">\(\max(m: m \cdot x&#39; \leq a \land m \cdot y&#39; \leq b)\)</span> and we can find such <span class="math inline">\(d\)</span> using binary search.</p>
<!-- begin code -->
<div class="collapsed code-title" type="button" data-toggle="collapse" data-target="#codeProblemF" aria-expanded="false" aria-controls="collapseTwo">
<!-- title --> <i class="fas fa-caret-right"></i>
<p class="title">
Code
</p>
</div>
<div id="codeProblemF" class="collapse">
<pre class="cpp"><code>#include &lt;bits/stdc++.h&gt;
     
#define all(A) begin(A), end(A)
#define rall(A) rbegin(A), rend(A)
#define sz(A) int(A.size())
#define pb push_back
#define mp make_pair
     
using namespace std;
     
typedef long long ll;
typedef pair &lt;int, int&gt; pii;
typedef pair &lt;ll, ll&gt; pll;
typedef vector &lt;int&gt; vi;
typedef vector &lt;ll&gt; vll;
typedef vector &lt;pii&gt; vpii;
typedef vector &lt;pll&gt; vpll;

int main () {
  ios::sync_with_stdio(false); cin.tie(0);
  ll a, b, x, y;
  cin &gt;&gt; a &gt;&gt; b &gt;&gt; x &gt;&gt; y;
  ll g = __gcd(x, y);
  x /= g;
  y /= g;
  ll l = 0, r = 2e9;
  while (l != r) {
    ll m = (l + r + 1) / 2;
    if (m * x &lt;= a and m * y &lt;= b) l = m;
    else r = m - 1;
  }
  cout &lt;&lt; l * x &lt;&lt; &#39; &#39; &lt;&lt; l * y &lt;&lt; &#39;\n&#39;;
  return (0);
}</code></pre>
</div>
<p><!-- ends code --></p>
</div>
</div>
</div>
<!-- ends problem F -->
<p style="float: none; clear: both;">
</p>
<div class="pt-3" style="float: right;">
<p><a class="continue-link" href="./class-13.html" 
     data-toggle="tooltip" title="Game Theory I"> Next </a></p>
</div>
<div class="pt-3">
<p><a class="continue-link" href="./class-11.html"
     data-toggle="tooltip" title="Divide and Conquer I"> Previous </a></p>
</div>
<script>
  $('#all-classes').collapse('show');
  $('#class-12').addClass('active');
  const cur_class = document.getElementById('class-12');
  cur_class.scrollIntoView({
    behavior: 'smooth',
    block: 'center'
  });
</script>
</div>

</div> <!-- ends wrapper -->
</div> <!-- ends content -->


<script type="text/javascript">

$(document).ready(function () {
  $('#dismiss-left').on('click', function () {
    $('#sidebar, #content').addClass('active');
  });

  $('#dismiss-right').on('click', function () {
    $('#sidebar, #content').removeClass('active');
  });

  $('#expand-icon-right').on('click', function () {
    document.getElementById('sidebar').style.width = "90px";
    document.getElementById('expand-icon-right').style.display = "none";
    document.getElementById('expand-icon-left').style.display = "block";
    $('#expand-icon-left').addClass('moved');
    $('#expand-icon-right').addClass('moved');
  });

  $('#expand-icon-left').on('click', function () {
    document.getElementById('sidebar').style.width = "0px";
    document.getElementById('expand-icon-right').style.display = "block";
    document.getElementById('expand-icon-left').style.display = "none";
    $('#expand-icon-left').removeClass('moved');
    $('#expand-icon-right').removeClass('moved');
  });

});

</script>

<script type="text/javascript" src="lib/lightbox-plus-jquery.min.js"></script>

<!--
<footer>
  <p>Copyright &copy; 2020. Competitive Programming UTEC</p>
</footer>
-->



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
